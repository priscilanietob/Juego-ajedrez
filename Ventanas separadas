//Codigo con las ventanas separadas de ventana menu y ventana juego

#include <SFML/Graphics.hpp>
#include <iostream>
using namespace std;
using namespace sf;

// Función para cargar texturas desde un archivo
bool cargarTextura(Texture& textura, const string& archivo)
{
    if (!textura.loadFromFile(archivo))
    {
        cerr << "Error al cargar el archivo " << archivo << endl;
        return false;
    }
    return true;
}


int main()
{
    //carga la tipografia arial para las coordenadas
    Font font;
    if (!font.loadFromFile("arial.ttf.ttf")) { //busca el archivo de font y despliega error si no se encuentra.
        cerr << "Error al cargar el archivo de letra." << endl;
        return 0;
    }

    RenderWindow ventanaMenu(VideoMode(600, 330), "Main Menu"); //Crear ventana para el menu de inicio

    Texture texturaFondo, texturaPlay, texturaSettings, texturaExit; //Crear las texturas de los botones
    cargarTextura(texturaFondo, "fondo.png");
    cargarTextura(texturaPlay, "Play_resized.png");
    cargarTextura(texturaSettings, "Settings_resized.png");
    cargarTextura(texturaExit, "Exit_resized.png");

    Sprite spriteFondo(texturaFondo);//Creo el sprite del fondo
    spriteFondo.setScale((float)ventanaMenu.getSize().x / spriteFondo.getTexture()->getSize().x, (float)ventanaMenu.getSize().y / spriteFondo.getTexture()->getSize().y); //Ajusta el tamaño del sprite del fondo a la ventana

    Sprite play(texturaPlay), Settings(texturaSettings), Exit(texturaExit); //Posicion de las texturas de botones (debe ser la misma que de los botones)
    play.setPosition(100, 50);
    Settings.setPosition(100, 150);
    Exit.setPosition(100, 250);

    // Creacion de botones
    RectangleShape botonPlay(Vector2f(200, 60)); //Tamaño y posicion de los botones
    botonPlay.setPosition(100, 50);

    RectangleShape botonSettings(Vector2f(200, 60));
    botonSettings.setPosition(100, 150);

    RectangleShape botonExit(Vector2f(200, 60));
    botonExit.setPosition(100, 250);

    RectangleShape botonExitGame(Vector2f(100, 60));
    botonExitGame.setPosition(850, 900);
    botonExitGame.setFillColor(Color::Red);

    RenderWindow ventanaJuego(VideoMode(1000, 1000), "Tablero");
    ventanaJuego.setVisible(false); 

    // Bucle principal
    while (ventanaMenu.isOpen() || ventanaJuego.isOpen()) 
    {
        if (ventanaMenu.isOpen())
        {
            Event evento;
            while (ventanaMenu.pollEvent(evento))
            {
                if (evento.type == Event::Closed)
                    ventanaMenu.close();
                else if (evento.type == Event::MouseButtonPressed)
                {
                    if (evento.mouseButton.button == Mouse::Left)
                    {
                        Vector2i mousePos = Mouse::getPosition(ventanaMenu);
                        if (botonPlay.getGlobalBounds().contains(mousePos.x, mousePos.y))
                        {
                            ventanaMenu.setVisible(false);
                            ventanaJuego.setVisible(true);
                        }
                        else if (botonExit.getGlobalBounds().contains(mousePos.x, mousePos.y))
                        {
                            ventanaMenu.close();
                        }
                    }
                }
            }
             ventanaMenu.clear();
             ventanaMenu.draw(spriteFondo);
             ventanaMenu.draw(botonPlay);
             ventanaMenu.draw(play);
             ventanaMenu.draw(botonSettings);
             ventanaMenu.draw(Settings);
             ventanaMenu.draw(botonExit);
             ventanaMenu.draw(Exit);
             ventanaMenu.display();
        }
        if (ventanaJuego.isOpen())
        {
            Event evento;
            while (ventanaJuego.pollEvent(evento))
            {
                if (evento.type == Event::Closed)
                    ventanaJuego.close();
            }
            ventanaJuego.clear();
    

             // Crear el cuadro para el tablero
            RectangleShape cuadro(Vector2f(100, 100));//tamanio de cada cuadro
            bool colorBlanco = true;

            // Funciones que imprimen las imagenes de los peones
            Texture texturaPeonBlanco, texturaPeonNegro;//TEXTURAS DE PEONES
            cargarTextura(texturaPeonBlanco, "peon_blanco_resized.png");
            cargarTextura(texturaPeonNegro, "peon_negro_resized.png");

            //TEXTURAS DE TORRES/ROOKS
            Texture texturaBRook, texturaWRook;
            cargarTextura(texturaBRook, "Rook B_resized.png");
            cargarTextura(texturaWRook, "Rook W_resized.png");

            //TEXTURAS DE CABALLOS/KNIGHTS
            Texture texturaBKnight, texturaWKnight;
            cargarTextura(texturaBKnight, "BKnight_resized.png");
            cargarTextura(texturaWKnight, "WKnight_resized.png");

            //TEXTURAS DE ALFIL/BISHOP
            Texture texturaBBishop, texturaWBishop;
            cargarTextura(texturaBBishop, "BBishop_resized.png");
            cargarTextura(texturaWBishop, "WBishop_resized.png");

            //TEXCTURAS DE LA REINA/QUEEN
            Texture texturaBQueen, texturaWQueen;
            cargarTextura(texturaBQueen, "BQueen_resized.png");
            cargarTextura(texturaWQueen, "WQueen_resized.png");

            //TEXTURAS DEL REY/KING
            Texture texturaBKing, texturaWKing;
            cargarTextura(texturaBKing, "BKing_resized.png");
            cargarTextura(texturaWKing, "WKing_resized.png");

            Sprite BRook, WRook, BKnight, WKnight, WBishop, BBishop, BQueen, WQueen, WKing, BKing;

            // Posiciones iniciales de los peones
            const int numPeones = 8;
            Sprite peonesBlancos[numPeones], peonesNegros[numPeones];

            for (int i = 0; i < numPeones; i++)
            {
                //for para establecer la posicion de las piezas
                peonesBlancos[i].setTexture(texturaPeonBlanco);
                peonesNegros[i].setTexture(texturaPeonNegro);

                peonesBlancos[i].setPosition(i * 100, 600);
                peonesNegros[i].setPosition(i * 100, 100);
            }
                // Dibujar el tablero
                for (int i = 0; i < 8; ++i)
                {
                    for (int j = 0; j < 8; ++j)
                    {
                        cuadro.setFillColor(colorBlanco ? Color::White : Color::Black);
                        cuadro.setPosition(j * 100, i * 100);
                        ventanaJuego.draw(cuadro);
                        colorBlanco = !colorBlanco;
                    }
                    colorBlanco = !colorBlanco;
                }

                //define el texto, su tamanio y color
                Text text;
                text.setFont(font);
                text.setCharacterSize(30);
                text.setFillColor(sf::Color::White);

                // posiciones iniciales para letras y numeros
                int letrasss = 30;
                int numeros = 40;

                // Dibujar las letras (A-H)
                for (int i = 0; i < 8; ++i) {
                    char letras = 'A' + i;
                    text.setString(std::string(1, letras));
                    text.setPosition(letrasss + i * 100, 800);
                    ventanaJuego.draw(text);
                }

                // Dibujar los números (1-8)
                for (int i = 0; i < 8; ++i) {
                    char num = '8' - i;
                    text.setString(std::string(1, num));
                    text.setPosition(815, numeros + i * 100);
                    ventanaJuego.draw(text);
                }


                // Dibujar los peones blancos
                for (int i = 0; i < numPeones; i++)
                {
                    ventanaJuego.draw(peonesBlancos[i]);
                }

                // Dibujar los peones negros
                for (int i = 0; i < numPeones; i++)
                {
                    ventanaJuego.draw(peonesNegros[i]);
                }
                //Dibujar los rooks, caballos y bishops
                for (int i = 0; i < 2; i++)
                {
                    WRook.setTexture(texturaWRook);
                    BRook.setTexture(texturaBRook);

                    WKnight.setTexture(texturaWKnight);
                    BKnight.setTexture(texturaBKnight);

                    WBishop.setTexture(texturaWBishop);
                    BBishop.setTexture(texturaBBishop);

                    BRook.setPosition(i * 700, 0);
                    WRook.setPosition(i * 700, 700);

                    BKnight.setPosition(i * 500 + 100, 0);
                    WKnight.setPosition(i * 500 + 100, 700);

                    BBishop.setPosition(i * 300 + 200, 0);
                    WBishop.setPosition(i * 300 + 200, 700);

                    ventanaJuego.draw(WRook);
                    ventanaJuego.draw(BRook);

                    ventanaJuego.draw(WKnight);
                    ventanaJuego.draw(BKnight);

                    ventanaJuego.draw(WBishop);
                    ventanaJuego.draw(BBishop);
                }

                //QUEEN
                WQueen.setTexture(texturaWQueen);
                BQueen.setTexture(texturaBQueen);

                BQueen.setPosition(300, 0);
                WQueen.setPosition(300, 700);

                ventanaJuego.draw(WQueen);
                ventanaJuego.draw(BQueen);

                //KING
                WKing.setTexture(texturaWKing);
                BKing.setTexture(texturaBKing);

                BKing.setPosition(400, 0);
                WKing.setPosition(400, 700);

                ventanaJuego.draw(WKing);
                ventanaJuego.draw(BKing);

                ventanaJuego.draw(botonExitGame);
                if (ventanaJuego.isOpen())
                {
                    Event Cerrar;
                    while (ventanaJuego.pollEvent(Cerrar))
                    {
                        if (Cerrar.type == Event::Closed)
                            ventanaJuego.close();
                        else if (Cerrar.type == Event::MouseButtonPressed)
                        {
                            if (Cerrar.mouseButton.button == Mouse::Left)
                            {
                                Vector2i mousePos = Mouse::getPosition(ventanaJuego);
                                if (botonExitGame.getGlobalBounds().contains(mousePos.x, mousePos.y))
                                {
                                    ventanaJuego.close();

                                }
                            }
                        }
                    }
                }

            ventanaJuego.display();
        }
    }
    return 0;
}
